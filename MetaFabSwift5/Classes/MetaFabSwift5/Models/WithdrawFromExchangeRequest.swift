//
// WithdrawFromExchangeRequest.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct WithdrawFromExchangeRequest: Codable, JSONEncodable, Hashable {

    /** A valid EVM based address to withdraw to. For example, `0x39cb70F972E0EE920088AeF97Dbe5c6251a9c25D`. */
    public var address: String?
    /** Any wallet id within the MetaFab ecosystem to withdraw to. */
    public var walletId: String?
    /** The address of the currency (ERC20) token to withdraw from the exchange. If no currencyAddress or currencyId, and no collectionAddress or collectionId are provided, the native token held by the exchange will be withdrawn. */
    public var currencyAddress: String?
    /** A valid MetaFab currency id that represents the currency token to withdraw from the exchange. `currencyAddress` or `currencyId` can be provided when withdrawing currency. */
    public var currencyId: String?
    /** The address of the collection (ERC1155) for the items to withdraw from the exchange. If no currencyAddress and no collectionAddress is provided, the native token held by the exchange will be withdrawn. */
    public var collectionAddress: String?
    /** A valid MetaFab collection id that represents the collection for the items to withdraw from the exchange. `collectionAddress` or `collectionId` can be provided when withdrawing items. */
    public var collectionId: String?
    /** The specific itemIds of the provided collection to withdraw from the exchange. */
    public var itemIds: [Double]?

    public init(address: String? = nil, walletId: String? = nil, currencyAddress: String? = nil, currencyId: String? = nil, collectionAddress: String? = nil, collectionId: String? = nil, itemIds: [Double]? = nil) {
        self.address = address
        self.walletId = walletId
        self.currencyAddress = currencyAddress
        self.currencyId = currencyId
        self.collectionAddress = collectionAddress
        self.collectionId = collectionId
        self.itemIds = itemIds
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case address
        case walletId
        case currencyAddress
        case currencyId
        case collectionAddress
        case collectionId
        case itemIds
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(address, forKey: .address)
        try container.encodeIfPresent(walletId, forKey: .walletId)
        try container.encodeIfPresent(currencyAddress, forKey: .currencyAddress)
        try container.encodeIfPresent(currencyId, forKey: .currencyId)
        try container.encodeIfPresent(collectionAddress, forKey: .collectionAddress)
        try container.encodeIfPresent(collectionId, forKey: .collectionId)
        try container.encodeIfPresent(itemIds, forKey: .itemIds)
    }
}

