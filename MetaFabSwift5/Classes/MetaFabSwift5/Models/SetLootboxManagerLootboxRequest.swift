//
// SetLootboxManagerLootboxRequest.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct SetLootboxManagerLootboxRequest: Codable, JSONEncodable, Hashable {

    /** A unique lootbox id to use for this lootbox for the lootbox manager. If an existing lootbox id is used, the current lootbox will be updated but the existing number of opens will be kept. If you want to reset the number of opens for an existing lootbox, first remove it using the remove lootbox endpoint, then set it. */
    public var id: Int
    /** A valid EVM based ERC1155 or MetaFab game items contract address that represents the collection for input items required by this lootbox. `inputCollectionAddress` or `inputCollectionId` can optionally be provided. */
    public var inputCollectionAddress: String?
    /** A valid MetaFab collection id that represents the collection for input items required by this lootbox. `inputCollectionAddress` or `inputCollectionId` can optionally be provided. */
    public var inputCollectionId: String?
    /** An array of item ids from the provided input collection that are required to open this lootbox. Input items are burn upon opening a lootbox. */
    public var inputCollectionItemIds: [Int]?
    /** An array of amounts for each item id from the provided input collection that are required to open this lootbox. Item amounts array indices are reflective of the amount required for a given item id at the same index. */
    public var inputCollectionItemAmounts: [Int]?
    /** A valid EVM based ERC1155 or MetaFab game items contract address that represents the collection for possible output items given by this lootbox. `outputCollectionAddress` or `outputCollectionId` can optionally be provided. */
    public var outputCollectionAddress: String?
    /** A valid MetaFab collection id that represents the collection for possible output items given by this lootbox. `outputCollectionAddress` or `outputCollectionId` can optionally be provided. */
    public var outputCollectionId: String?
    /** An array of item ids from the provided output collection that are possibly given by this lootbox. Randomly selected output items are automatically minted if the lootbox manager contract has the `minter` role for the output collection contract. Otherwise, they are transferred from the item balance held by the lootbox manager contract. */
    public var outputCollectionItemIds: [Int]?
    /** An array of amounts for each item id that can be randomly selected from the provided output collection that are given by this lootbox. Item amounts array indices are reflective of the amount required for a given item id at the same index. */
    public var outputCollectionItemAmounts: [Int]?
    /** An array of weights for each item id that can be randomly selected from the provided output collection that are given by this lootbox. Any positive integer for an item's weight can be provided. The weight for an item relative to the sum of all possible item weights determines the probability that an item will be picked upon a lootbox being opened. Item weights array indices are reflective of the probability weight for a given item id at the same index. */
    public var outputCollectionItemWeights: [Int]?
    /** The number of items randomly selected from the possible output items when this lootbox is open. If you provide a value greater than 1, it is possible for the same item to be selected more than once, giving the opener more than one of that item's output from the lootbox. */
    public var outputTotalItems: Int?

    public init(id: Int, inputCollectionAddress: String? = nil, inputCollectionId: String? = nil, inputCollectionItemIds: [Int]? = nil, inputCollectionItemAmounts: [Int]? = nil, outputCollectionAddress: String? = nil, outputCollectionId: String? = nil, outputCollectionItemIds: [Int]? = nil, outputCollectionItemAmounts: [Int]? = nil, outputCollectionItemWeights: [Int]? = nil, outputTotalItems: Int? = nil) {
        self.id = id
        self.inputCollectionAddress = inputCollectionAddress
        self.inputCollectionId = inputCollectionId
        self.inputCollectionItemIds = inputCollectionItemIds
        self.inputCollectionItemAmounts = inputCollectionItemAmounts
        self.outputCollectionAddress = outputCollectionAddress
        self.outputCollectionId = outputCollectionId
        self.outputCollectionItemIds = outputCollectionItemIds
        self.outputCollectionItemAmounts = outputCollectionItemAmounts
        self.outputCollectionItemWeights = outputCollectionItemWeights
        self.outputTotalItems = outputTotalItems
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case id
        case inputCollectionAddress
        case inputCollectionId
        case inputCollectionItemIds
        case inputCollectionItemAmounts
        case outputCollectionAddress
        case outputCollectionId
        case outputCollectionItemIds
        case outputCollectionItemAmounts
        case outputCollectionItemWeights
        case outputTotalItems
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(id, forKey: .id)
        try container.encodeIfPresent(inputCollectionAddress, forKey: .inputCollectionAddress)
        try container.encodeIfPresent(inputCollectionId, forKey: .inputCollectionId)
        try container.encodeIfPresent(inputCollectionItemIds, forKey: .inputCollectionItemIds)
        try container.encodeIfPresent(inputCollectionItemAmounts, forKey: .inputCollectionItemAmounts)
        try container.encodeIfPresent(outputCollectionAddress, forKey: .outputCollectionAddress)
        try container.encodeIfPresent(outputCollectionId, forKey: .outputCollectionId)
        try container.encodeIfPresent(outputCollectionItemIds, forKey: .outputCollectionItemIds)
        try container.encodeIfPresent(outputCollectionItemAmounts, forKey: .outputCollectionItemAmounts)
        try container.encodeIfPresent(outputCollectionItemWeights, forKey: .outputCollectionItemWeights)
        try container.encodeIfPresent(outputTotalItems, forKey: .outputTotalItems)
    }
}

