//
// LootboxManagerLootbox.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct LootboxManagerLootbox: Codable, JSONEncodable, Hashable {

    /** The id of this lootbox. */
    public var id: Int?
    /** The address of the ERC1155 or MetaFab game items contract for input items required by this lootbox. */
    public var inputCollection: String?
    /** An array of item ids from the input collection that are required for this lootbox. */
    public var inputCollectionItemIds: [Int]?
    /** An array of amounts for each item id for the input collection that are required to open this lootbox. */
    public var inputCollectionItemAmounts: [Int]?
    /** The address of the ERC1155 of MetaFab game items contract for possible output items given by this lootbox. */
    public var outputCollection: String?
    /** An array of item ids from the output collection that are possibly given by this lootbox. */
    public var outputCollectionItemIds: [Int]?
    /** An array of amounts for each item id for the output collection that are possibly given by this lootbox. */
    public var outputCollectionItemAmounts: [Int]?
    /** An array of weights for each item id for the output collection that are possibly given by this lootbox. */
    public var outputCollectionItemWeights: [Int]?
    /** The number of items randomly selected when this lootbox is opened. */
    public var outputTotalItems: Int?
    /** A unix timestamp in seconds that represents the last time this offer was set or updated. */
    public var lastUpdatedAt: Int?

    public init(id: Int? = nil, inputCollection: String? = nil, inputCollectionItemIds: [Int]? = nil, inputCollectionItemAmounts: [Int]? = nil, outputCollection: String? = nil, outputCollectionItemIds: [Int]? = nil, outputCollectionItemAmounts: [Int]? = nil, outputCollectionItemWeights: [Int]? = nil, outputTotalItems: Int? = nil, lastUpdatedAt: Int? = nil) {
        self.id = id
        self.inputCollection = inputCollection
        self.inputCollectionItemIds = inputCollectionItemIds
        self.inputCollectionItemAmounts = inputCollectionItemAmounts
        self.outputCollection = outputCollection
        self.outputCollectionItemIds = outputCollectionItemIds
        self.outputCollectionItemAmounts = outputCollectionItemAmounts
        self.outputCollectionItemWeights = outputCollectionItemWeights
        self.outputTotalItems = outputTotalItems
        self.lastUpdatedAt = lastUpdatedAt
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case id
        case inputCollection
        case inputCollectionItemIds
        case inputCollectionItemAmounts
        case outputCollection
        case outputCollectionItemIds
        case outputCollectionItemAmounts
        case outputCollectionItemWeights
        case outputTotalItems
        case lastUpdatedAt
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(id, forKey: .id)
        try container.encodeIfPresent(inputCollection, forKey: .inputCollection)
        try container.encodeIfPresent(inputCollectionItemIds, forKey: .inputCollectionItemIds)
        try container.encodeIfPresent(inputCollectionItemAmounts, forKey: .inputCollectionItemAmounts)
        try container.encodeIfPresent(outputCollection, forKey: .outputCollection)
        try container.encodeIfPresent(outputCollectionItemIds, forKey: .outputCollectionItemIds)
        try container.encodeIfPresent(outputCollectionItemAmounts, forKey: .outputCollectionItemAmounts)
        try container.encodeIfPresent(outputCollectionItemWeights, forKey: .outputCollectionItemWeights)
        try container.encodeIfPresent(outputTotalItems, forKey: .outputTotalItems)
        try container.encodeIfPresent(lastUpdatedAt, forKey: .lastUpdatedAt)
    }
}

